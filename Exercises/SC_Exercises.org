
* Beginner

** variables
*** start a sound and stop it
*** start a sound and stop it with a decay (fade out time) of 5 seconds
*** start 2 sounds and stop the first one without stopping the second one

*** Find and correct the error here

a = 1;
beta = a.sqrt;
a + beta;

** SynthDefs

** Envelopes

** Arrays

*** create an array with the elements \a, 1, -1, \b, nil.

*** get the first element from this array: 

*** get the last element from this array:
*** get the 3d element from this array: [\a, \b, \c, \d, \e].

*** reverse the order of elements in this array:

*** calculate the sum of the elements of this array: 

*** create a nested array

*** post all elements in an array, each on a separate line

** Events

*** Play an event
*** Find out which are the keys added to an event by playing it.
*** Find out how many are the keys of the default parent event
*** List the keys of the default parent event
** Patterns 

* Intermediate

** Arrays

*** construct the series of numbers from 1 to 32 as an array, in 6 different ways

**** Using the Matlab shortcut
**** With an operator on an array generated by dup
**** Iterating a function
**** With a routine that works as Stream
**** With a Stream
**** With a function that returns a function
*** Play the above series in n different ways
**** With a routine
**** With a pattern
**** With a synth ...

*** "=mpairs=": given an array of n elements, create an array that pairs each element of the array with the element of the same array in reverse order. 

**** problem
  For example: Let us call the method that does the operation =mpairs=.
  Then =[ 'a', 'b', 'c', 'd' ].mpairs= should return: 

 #+begin_src sclang
  [ [ 'a', 'd' ], [ 'b', 'c' ], [ 'c', 'b' ], [ 'd', 'a' ] ]
 #+end_src

**** solution
***** As Function
 #+begin_src sclang
 //: 1: define the function
 ~mirror2 = { | list |
      list.mirror2.clump(list.size).flop;
 };
 //: 2: test the function
 ~mirror2.((1..4));
 // Returns: [ [ 1, 4 ], [ 2, 3 ], [ 3, 2 ], [ 4, 1 ] ]
 ~mirror2.((1..5));
 // Returns: [ [ 1, 5 ], [ 2, 4 ], [ 3, 3 ], [ 4, 2 ], [ 5, 1 ] ]
 #+end_src
***** As Method
 #+begin_src sclang
 + SequenceableCollection {
      mpairs {
           ^this.mirror2.clump(this.size).flop;
      }
 }
 #+end_src

*** Start 7 Synths with frequencies taken from the midi notes [60, 62, 63, 66, 67, 68, 72], and release them with fades taken from [0.1, 0.5, 1, 2, 5, 7, 0.1], 

Do the release with 1 statement for all 7 synths.
*** start 89 sounds, then stop the 2nd, 3d, 5th, 8th, 13th, 21st, 34th, 55th sound at once, all together.

 More difficult variant: Devise an algorithmic way for selecting the 2nd, 3d, 5th, 8th, 13th, 21st, 34th, 55th synth, without typing those numbers in the code.

** Functions

*** create a function that counts to infinity, starting from 5.
*** create a function that produces the fibonacci numbers
*** create a function or method =recurse= for recursing over all elements of a tree
**** Specification / Parts of the function:

  1. a function/method to perform if the node of the tree is a tree (or collection?)
  2. a function/method to perform if the node of the tree is a leaf
  3. a function to perform on a tree to return its immediate subtree branches
**** Implementation hint: Use =respondsTo:=
     :PROPERTIES:
     :DATE:     <2020-12-12 Sat 02:57>
     :END:

 Hint: You can use the message =respondsTo:= to determine whether the receiver can iterate.

 Further problem: Some types of objects may need a different message to produce their list of branches. Should this be given as method name (Symbol), or as a function in an additional argument "=iterator=" (point 3 above)?

 For example, if applying =recurse= over a Class to recurse on its subclass tree, the =iterator= message should be =subclasses=. 

 Draft: 

 #+begin_src sclang
 f = { | receiver, ifBranch, ifFleaf /*, iterator = \do */ |
     if (receiver respondsTo: \do) { // alternatively to \do: iterator
         ifBranch.(receiver);
     }{
         ifLeaf.(receiver);
         // alternatively: (receiver.perform(iterator) do: ... )
         receiver do: { | branch |
             f.(branch, ifBrach, ifFleaf /*, iterator */);
         }
     }
 };
 #+end_src

** Synths

*** Design a synth algorithm using additive synthesis that produces a pulse wave 
*** Design a synth algorithm using additive synthesis that produces a saw wave 
*** Write a function that takes as input another function and treats it as trigger for sending '/tr' messages via SynthTrig
** Patterns
*** Program the jumping pattern from Intro to Carnatic Music
    :PROPERTIES:
    :DATE:     <2020-12-11 Fri 15:03>
    :END:

 Hint: Use + operation to combine a Pseq with a nested pattern.
** Classes
*** Write a class for representing and that performing arithmetic on rational numbers

 Define a binary operator for producing a rational integer from a numerator and a denominator.

 A rational numbers should print as: (numerator/denominator). For example: (2/3)

 Rational numbers should automatically simplify to smallest numerator/denominator.

 Implement all operations described in:
 https://en.wikipedia.org/wiki/Rational_number
 (Note: as operators)

 Further references:

 https://mitpress.mit.edu/sites/default/files/sicp/full-text/sicp/book/node28.html
 http://www.blackwasp.co.uk/RationalNumberArithmetic.aspx

*** Combine patterns in 2 different ways: (a) nesting. (b) binary operators
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 15:03>
    :END:
*** Design a way to play a pattern with crossfade between events

 Each event plays a function that contains the crossfade envelope, and plays it with a sound function as signal input.

 Draft: 
 #+begin_src sclang
 var func;
 func = { PinkNoise.ar(0.1) };

 { func * Env.adsr(1, 1, 1, 1, 1).kr(2) }
 #+end_src

* Advanced

** Recursive functions

Define functions for solving following problems, using recursion:

- Factorial
- Hemachandra (Fibonacci) numbers
- Hemachandra generation of metric patterns
- Generation of Euclidean rhythms through partitioning
- Tree traversal (many cases)
  - See inorder, preorder, postorder: https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/

** Meters/Rhythm Patterns, Polyrhythms, Konnakol
*** Program the Euclidean Rhythm algorithm by G. Toussaint
    :PROPERTIES:
    :DATE:     <2021-01-15 Fri 13:16>
    :END:

Original soure paper:

https://en.wikipedia.org/wiki/Euclidean_rhythm
http://cgm.cs.mcgill.ca/~godfried/publications/banff.pdf

Supporting studies online with explanations on algorithm implementations:

1. https://medium.com/code-music-noise/euclidean-rhythms-391d879494df
2. https://www.computermusicdesign.com/simplest-euclidean-rhythm-algorithm-explained/
3. https://dev.to/erwald/euclidean-rhythms-and-haskell-5ecj

Suggestion: 

1. Start with Bresenham’s line algorithm described in site 1 above. (code-music-noise).
2. Then explore the original Bjorklund algorithm described also in site 1.
3. Finally, try to see how the Bjorklund algorithm is reflected in the numerical algorithms described by Toussaint and the other sites.

(Note 15 Jan 2021 13:19: See coding attempt in SC-Hacks repo)

*** Program polyrhythms using demand UGens.  Can you change the number of beats in a cycle while playing?
*** Program the 75/16 Tatighinathom pattern from the Extreme Math Nerd Music Youtube video
    :PROPERTIES:
    :DATE:     <2020-12-11 Fri 14:30>
    :END:

 https://www.youtube.com/watch?v=-mS06lEmY3s

*** Program the Twinkle Twinkle Little Star pattern by Manjunath - with sample cutting
    :PROPERTIES:
    :DATE:     <2020-12-11 Fri 14:41>
    :END:

 OFF BEAT TWINKLE TWINKLE LITTLE STAR
 https://www.youtube.com/watch?v=6aHWJKJe9mU

** Indian Music Theory - Vocal ornaments + Pattern combinations
*** Make a short piece with simple examples of gamakas based on dynamic envelopes
    :PROPERTIES:
    :DATE:     <2021-01-21 Thu 14:44>
    :END:

Start with these examples from https://doc.sccode.org/Classes/EnvGen.html

#+begin_src sclang
(
SynthDef(\help_Env_newClear, { |out = 0|
    var env, envctl;
    // make an empty 4 segment envelope
    env = Env.newClear(4);
    // create a control argument array
    envctl = \env.kr(env.asArray);
    Out.ar(out,
        SinOsc.ar(EnvGen.kr(envctl, \gate.tr), 0, 0.3) // the gate control is a trigger
    );
}).add;
)

Synth(\help_Env_newClear, [\gate, 1, \env, Env([700,900,900,800], [1,1,1], \exp)]); // 3 segments

// reset then play again:
Synth(\help_Env_newClear, [\gate, 1, \env, Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)]);

// the same written as an event:
(instrument: \help_Env_newClear, gate: 1, env: Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)).play;
#+end_src

#+begin_src sclang
// Changing an Env while playing
(
SynthDef(\env, { arg i_outbus=0;
    var env, envctl;

    // make a dummy 8 segment envelope
    env = Env.newClear(8);

    // create a control argument array
    envctl = \env.kr( env.asArray );

    ReplaceOut.kr(i_outbus, EnvGen.kr(envctl, doneAction: Done.freeSelf));
}).add;
)

(
SynthDef(\sine, { |out, freq = 440|
    Out.ar(out, SinOsc.ar(freq, 0, 0.2));
}).add;
)

f = Bus.control(s, 1);
f.set(800);

// use f's control bus value for frequency
// i.e. *map* the control to read from the bus
a = Synth(\sine, [freq: f.asMap]);

Synth(\env, [i_outbus: f, env: Env([700, 900, 900, 800], [1, 1, 1]*0.4, \exp)]);

Synth(\env, [i_outbus: f, env: Env([1000, 1000, 800, 1000, 900, 1000], [1, 1, 1, 1, 1]*0.3, \step)]);

a.free;
f.free;
#+end_src

*** Program the 22 shrutis using rational numbers

https://en.wikipedia.org/wiki/Shruti_(music)

*** Devise a way to play Tisram and Gati in patterns - in a single melody
*** Devise a way to play Gamakas in patterns
*** Devise a way to play Brighas in  patterns
*** Devise a way to play polyrhythmic tisram in patterns - in parallel, synchronized sharing a basic beat
** Greek and Near Eastern Music Theory - Tunings - Scales
*** Program Turkish tunings based on (Mercator/Holder) 53-division of the octave

See;
 Holdrian Comma 
https://en.wikipedia.org/wiki/Holdrian_comma
https://en.wikipedia.org/wiki/53_equal_temperament
https://en.wikipedia.org/wiki/Nicholas_Mercator


*** Program Greek tunings based on the (Karas/Epitropi) 72 division of the octave
*** Program Greek tunings based on the (Chrysanthos) 68 division of the octave 
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 15:50>
    :END:

http://www.pandoura.gr/armoniko-egxeiridio/ti-den-mas-eipan-gia-to-xrisantho
*** Program the tetrachords from the Αρμονικά of Κλαύδιος Πτολεμαίος
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 16:33>
    :END:

(Use the rational number class from Intermediate exercises above).

*** Program the helikon and kanon from the Αρμονικά of Κλαύδιος Πτολεμαίος
    :PROPERTIES:
    :DATE:     <2020-12-11 Fri 14:55>
    :END:
** Western Music Theory
*** Program Messiaen's Modes of Limited Transposition
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 14:59>
    :END:

https://www.youtube.com/watch?v=nCXxV7eDEPc
*** Program Messiaen's Mode de valeurs et d'intensités
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 15:01>
    :END:

https://messiaenandmath.tumblr.com/modedevaleurs

https://en.wikipedia.org/wiki/Quatre_%C3%89tudes_de_rythme

https://www.youtube.com/watch?v=tippo8S5YlI

https://www.youtube.com/watch?v=S3xEnDpM1mU

Messiaen: Quatre Études de Rythme, with score - II. Mode de valeurs et d'intensités
*** Program A. Forte's Pitch Class Sets
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 15:07>
    :END:
*** Program A. Schoenberg's (equal tempered) tone net
*** Program M. Vogel's 3-5-7 just tone net and its 171-pitch/octave temered approximation
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 17:55>
    :END:

*** Program Schillinger's rhythmic + melodic patterns

** New types of Patterns
*** Palindromes: Fine a method or class for converting a sequential pattern into its palindrome

*** Define a method or class for playing a =Pseq= as a sequence of pairs generated with the =mpairs= method defined above under [[Intermediate]] exercises (i.e. concurrent palindrome with itself). 

    :PROPERTIES:
    :DATE:     <2020-12-12 Sat 03:13>
    :END:

*** Which other patterns besides =Pseq= can work with =mpairs=?
    :PROPERTIES:
    :DATE:     <2020-12-12 Sat 03:14>
    :END:

*** Program a way to play concurrently 2^n permutations of a Fibonacci beat pattern
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 17:54>
    :END:

*** Program a list pattern which gives access to the list data of the stream for on-the-fly modification
*** Program a way to share a data structure in multiple patterns playing in parallel.  
*** Program a way to select pitches or harmonic structures by solving optimization problems on the fly in a polyphonic pattern sharing a harmonic field data structure

 Hint: list comprehensions
*** Program feedback in patterns and compare to feedback in signals
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 11:37>
    :END:

* List of toopics to cover
** Variables

*** Interpreter Variables

 Store a synth in an interpreter variable, and free it.

 Store a synth in an interpreter variable, and release it, with a release duration of 7 seconds.

*** Environment Variables

*** Variables in closures

*** Variables in methods

*** Arguments as variables

*** Special Variables

 What is the value of =this= in the following code: 



 What is the value of =this= in the following code: 

** Arrays
*** Array creation
**** [\a, \b, \c]
**** Array.newClear
**** Array.fill
**** Array.rand
**** (1..10)
**** (1, 1.5 .. 10)
**** Array.series
**** Array.geom
**** Array.fib
**** Array.rand
**** Array.rand2
**** Array.linrand
**** Array.exprand
**** Array.interpolation

*** Accessing Array elements

**** [1, 2, 3][1]
**** (1..10)[5..]
**** (1..10)[..2]
**** =(1..10)[[1,3]]=
**** (1..10)@0
**** (1..10)@12
**** (1..10)@@12
**** (1..10).at(0)
**** (1..10).at(20)
**** (1..10).clipAt(20)
**** (1..10).wrapAt(20)
**** (1..10).foldAt(20)
**** (1..10).first;
**** (1..10).last;
**** [3, 4, 5]@|@[6, 8]
**** [3, 4, 5]|@|6
*** Searching in Arrays
**** indexOf
**** indicesOf
**** indexOfEqual
**** indicesOfEqual
**** includes
*** Replacing Array elements
**** (1..10).put(3, \x);
**** =(1..10)[[1,3]] = [\x, \y];=
*** Iterating over Arrays
**** (40..50) do: { ... }
**** (40..50) collect: { ... }
**** (40..50) select: { ... }
**** (40..50) reject: { ... }
*** Manipulating array structure
**** flop
**** flat
**** bubble
**** curdle
**** scramble
**** stutter
**** pyramid
**** j operations
*** Numeric operations and applications of Arrays
**** Adverbs for binary operators

** Control structures

*** if () { } { }
*** while
*** loop
*** case
*** switch
*** ?
*** !?
** List comprehensions
** Returning results
*** ^
** Synth Parameter Control
** Freeing and Releasing Synths
*** 
** Envelopes
*** Creating Envelopes
*** Triggering Envelopes
*** Releasing Envelopes

** Signals

** Buffers

*** Play a buffer reversed (back to front)

*** Play a buffer starting from the middle of the buffer

*** Buffer grains

** Mouse control

** Gui control
*** using defer in GUIs
** Buses and Synth IO
** Synth Order
** Routines
** Patterns + Streams
*** Sequential Patterns
*** Random Patterns
*** Combining Patterns
**** Arithmetic operations on Patterns
***** x adverb for binary operators on Streams
**** Nesting Patterns
**** Pn vs Pstutter
**** Filter Patterns

** Events
*** changing the instrument (synthdef used)
*** playing chords
*** synchronising
*** monophonic
*** legato
*** arpeggio
** Sched and Clocks
*** AppClock - TempoClock - SystemClock
** Closures

 what is the value of this in the following cases: ... 

 use a closure to count
** Scales and Tunings
*** midi - cents - midicps
** Demand UGens
** Duty and TDuty
** linear and exponential range use and conversion
** Line
** ControlSpecs
** UGens and Synthesis Techniques
*** Additive Synthesis
*** Subtractive Synthesis
**** Filter Ugens
*** Resonance
**** Ringz
**** Resonz
**** Klank
**** DynKlank,
**** Klang
*** Spectral Processing
*** Delays, Decays, Reverb
**** JPverb
**** JPverbRaw
**** GVerb
**** Delay
**** Decay
**** Comb
**** AllPass

*** Wavetable synthesis
*** Noise and Chaos UGens
**** Kinds of Noise: WhiteNoise
**** Kinds of LFNoise:
**** Chaos UGens

** Plotting signals + data
** Synthesizing signals (numerically/algorithmically)
** Multichannel expansion
** Multichannel output
*** Pan2, PanAz
*** Ambisonics
** File IO

